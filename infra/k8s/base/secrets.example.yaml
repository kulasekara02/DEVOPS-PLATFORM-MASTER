# =============================================================================
# Secrets Example - DO NOT COMMIT ACTUAL SECRETS
# =============================================================================
# This is an example file showing the structure of secrets.
# Create your actual secrets using:
#   kubectl create secret generic app-secrets --from-literal=key=value
# Or using sealed-secrets/external-secrets-operator in production.
#
# For GitHub Actions, store secrets in repository secrets and inject at deploy time.
# =============================================================================
---
apiVersion: v1
kind: Secret
metadata:
  name: app-secrets
  namespace: devops-platform
  labels:
    app.kubernetes.io/name: devops-platform
    app.kubernetes.io/part-of: devops-platform-master
type: Opaque
stringData:
  # Database credentials
  # Generate strong passwords and store in GitHub Secrets:
  # - POSTGRES_USER
  # - POSTGRES_PASSWORD
  POSTGRES_USER: "devops"
  POSTGRES_PASSWORD: "CHANGE_ME_IN_PRODUCTION"
  DATABASE_URL: "postgresql://devops:CHANGE_ME_IN_PRODUCTION@postgres:5432/devops_platform"

  # Redis credentials (if using authentication)
  REDIS_PASSWORD: ""
  REDIS_URL: "redis://redis:6379/0"

  # JWT Secret - Generate with: openssl rand -base64 32
  JWT_SECRET: "CHANGE_ME_GENERATE_STRONG_SECRET"

  # API Key for service-to-service communication
  API_KEY: "CHANGE_ME_GENERATE_STRONG_KEY"

  # Encryption key (32 bytes for AES-256)
  ENCRYPTION_KEY: "CHANGE_ME_32_BYTE_KEY_HERE_____"

---
# =============================================================================
# Image Pull Secret Example (for private registries)
# =============================================================================
# apiVersion: v1
# kind: Secret
# metadata:
#   name: registry-credentials
#   namespace: devops-platform
# type: kubernetes.io/dockerconfigjson
# data:
#   .dockerconfigjson: <base64-encoded-docker-config>

---
# =============================================================================
# TLS Secret Example (for Ingress)
# =============================================================================
# Generate self-signed cert for local development:
#   openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
#     -keyout tls.key -out tls.crt -subj "/CN=devops.local"
#
# Then create secret:
#   kubectl create secret tls tls-secret --key tls.key --cert tls.crt -n devops-platform
# =============================================================================
# apiVersion: v1
# kind: Secret
# metadata:
#   name: tls-secret
#   namespace: devops-platform
# type: kubernetes.io/tls
# data:
#   tls.crt: <base64-encoded-cert>
#   tls.key: <base64-encoded-key>

# =============================================================================
# HOW TO USE GITHUB SECRETS
# =============================================================================
# 1. Store secrets in GitHub repository settings:
#    Settings -> Secrets and variables -> Actions -> New repository secret
#
# 2. In your GitHub Actions workflow, create the secret at deploy time:
#
#    - name: Create Kubernetes Secrets
#      run: |
#        kubectl create secret generic app-secrets \
#          --from-literal=DATABASE_URL="${{ secrets.DATABASE_URL }}" \
#          --from-literal=JWT_SECRET="${{ secrets.JWT_SECRET }}" \
#          --from-literal=REDIS_URL="${{ secrets.REDIS_URL }}" \
#          --namespace devops-platform \
#          --dry-run=client -o yaml | kubectl apply -f -
#
# 3. For production, consider:
#    - Sealed Secrets (Bitnami)
#    - External Secrets Operator
#    - HashiCorp Vault
#    - AWS Secrets Manager / Azure Key Vault / GCP Secret Manager
# =============================================================================
